<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="Author" content="Jamie Wright">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Publications</title>
  <link rel="shortcut icon" type="image/x-icon" href="./images/JW.ico" />
  <link rel="stylesheet" href="./css/index.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body>
    <!-- Desktop Menu -->
  <header>
    <div id="header-wrapper">
      <div class="menu-logo"> 
        <a href="index.html">
                    <svg width="200" height="60" xmlns="http://www.w3.org/2000/svg">
            <text x="10" y="40" font-family="Segoe UI, sans-serif" font-size="36" fill="#333">
              <tspan font-weight="bold">J</tspan>Wright
            </text>
          </svg>  
        </a>
      </div>
      <div id="menu-desktop">
        <nav class="desktop-nav">
          <ul>
              <li><a class="menu-item-text" href="index.html">Home</a></li>
              <li><a class="menu-item-text" href="about.html">About/News</a></li>
              <li><a class="menu-item-text" href="Jamie_Wright_CV.pdf">CV</a></li>
              <li><a class="menu-item-text" href="publications.html">Publications</a></li>
              <li><a class="menu-item-text" href="teaching.html">Teaching</a></li>
          </ul>
        </nav>
      </div>
    </div>
  </header>
  
  <div id="wrapper">

    <!-- Mobile Menu -->
    <div id="menu-mobile" class="sticky">
      <nav>
        <div class="collapsible-menu">
          <input type="checkbox" id="menu">
          <label for="menu" class = "menu-logo">           
            <svg width="200" height="60" xmlns="http://www.w3.org/2000/svg">
            <text x="10" y="40" font-family="Segoe UI, sans-serif" font-size="36" fill="#333">
              <tspan font-weight="bold">J</tspan>Wright
            </text>
          </svg>    
          </label>
          <div class="menu-content">
            <ul id="header-menu">
              <li><a class="menu-item-text" href="index.html">Home</a></li>
              <li><a class="menu-item-text" href="about.html">About/News</a></li>
              <li><a class="menu-item-text" href="Jamie_Wright_CV.pdf">CV</a></li>
              <li><a class="menu-item-text" href="publications.html">Publications</a></li>
              <li><a class="menu-item-text" href="teaching.html">Teaching</a></li>
            </ul>
          </div>            
        </div>        
      </nav>
    </div>
  
    <h1>Publications</h1>
    <div class="cover-image">
      <img src="./images/sheffield-cover.webp" alt="An image depicting an overhead view of the University of Sheffield from Endcliffe." width="300">
    </div>

    <main>
      <div class="Alt-sect">
      <p>
        Here you can find a list of my publications. They are listed in the following order: peer-reviewed publications, workshop papers, Isabelle AFP Entries (i.e. Archive of Formal Proofs).
      </p></div>
      
      <!--PUBLICATION TEMPLATE, copy and paste, filling in respective info-->
      <div class="flex-card">
          <div class="flex-card-content">
            <div class="flex-card-text">
              <h2 class="card-title">Rely-Guarantee Is Coinductive: A Proof-Centered Investigation of Inductively Approximated Coinduction</h2>
              <h3 class="card-description"><b>35th European Symposium on Programming (ESOP 2026) - To Appear</b></h3>
              <p class="card-description">
                We make the case that the foundation for Rely-Guarantee
                reasoning can be fruitfully delivered by a coinductive semantics. Using
                insight from an Isabelle formalization, via a proof analysis we show
                that the coinductive semantics tends to simplify the proof development;
                in particular it enables more direct proofs for the soundness of
                the Rely-Guarantee rules. The comparison between inductive and
                coinductive proofs also suggests inductive counterparts of coinductive
                “up-to” enhancements. On the way, we fill a gap in the literature,
                by showing that three previously defined inductive semantics for
                Rely-Guarantee are equivalent. Underlying our transformation of an
                inductive into a coinductive semantics is the notion of inductively
                approximating a coinductive predicate—which, deployed in the opposite
                direction (from coinduction to induction), is a standard technical tool for
                approximating process algebra bisimilarities. On the spectrum between
                the abstract fixpoint theorems and concrete instances, we formalize
                effective format-based criteria that enable sound approximation.
              </p>
            </div>     
            
            <a class="card-link" href="Rely_Guarantee_Is_Coinductive.pdf">
              <div class="card-highlight">
                <h3>Read more</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>

          </div>      
      </div>
      <div class="flex-card">
          <div class="flex-card-content">
            <div class="flex-card-text">
              <h2 class="card-title">Relative Security: Formally Modeling and (Dis)Proving Resilience Against Semantic Optimization Vulnerabilities</h2>
              <h3 class="card-description"><b>37th IEEE Computer Security Foundations Symposium (CSF 2024)</b></h3>
              <p class="card-description">
                Meltdown and Spectre are vulnerabilities known as transient execution vulnerabilities, where an attacker exploits speculative execution (a semantic optimization present in most modern processors) to break confidentiality. We introduce relative security, a general notion of information-flow security that models this type of vulnerability by contrasting the leaks that are possible in a “vanilla” semantics with those possible in a different semantics, often obtained from the vanilla semantics via some optimizations. We describe incremental proof methods, in the style of Goguen and Meseguer's unwinding, both for proving and for disproving relative security, and deploy these to formally establish the relative (in)security of some standard Spectre examples. Both the abstract results and the case studies have been mechanized in the Isabelle/HOL theorem prover.
              </p>
            </div>     
            
            <a class="card-link" href="https://www.computer.org/csdl/proceedings-article/csf/2024/620300a409/1W0eVVRRd04">
              <div class="card-highlight">
                <h3>Read more</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>

          </div>      
      </div>
      <div class="flex-card">
          <div class="flex-card-content">
            <div class="flex-card-text">
              <h2 class="card-title"> A formalized programming language with speculative execution</h2>
              <h3 class="card-description"><b>In Isabelle Workshop 2024, associated with ITP 2024</b></h3>
              <h3 class="card-description"><b>Archive Of Formal Proofs (AFP 2024)</b></h3>
              <p class="card-description">
                We present the formalization of a programming language whose operational semantics allows for the speculative execution of its statements. This type of semantics is relevant for discussing transient execution security vulnerabilities such as Spectre and Meltdown. An instantiation of Relative Security to this language is provided along with proofs of security and insecurity of selected programs from the Spectre benchmark.
              </p>
            </div>     
            
            <a class="card-link" href="https://files.sketis.net/Isabelle_Workshop_2024/Isabelle_2024_paper_4.pdf">
              <div class="card-highlight">
                <h3>Paper</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>            
            <a class="card-link" href="https://files.sketis.net/Isabelle_Workshop_2024/Isabelle_2024_paper_4.pdf">
              <div class="card-highlight">
                <h3>AFP entry</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>
          </div>      
      </div>
      <div class="flex-card">
          <div class="flex-card-content">
            <div class="flex-card-text">
              <h2 class="card-title">Relative Security</h2>
              <h3 class="card-description"><b>Archive Of Formal Proofs (AFP 2024)</b></h3>
              <p class="card-description">
                This entry formalizes the notion of relative security presented in the CSF 2024 paper “Relative Security: Formally Modeling and (Dis)Proving Resilience Against Semantic Optimization Vulnerabilities” by Brijesh Dongol, Matt Griffin, Andrei Popescu and Jamie Wright. It defines two versions of relative security: a finitary one (restricted to finite traces), and an infinitary one (working with both finite and infinite traces). It introduces unwinding methods for verifying relative security in both the finitary and infinitary versions, and proves their soundness. The proof of soudness in the infinitary case is a substantial application of Isabelle’s corecursion and coinduction infrastructure.
              </p>
            </div>     
            
            <a class="card-link" href="https://www.isa-afp.org/entries/Relative_Security.html">
              <div class="card-highlight">
                <h3>Read more</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>

          </div>      
      </div>
      <div class="flex-card">
          <div class="flex-card-content">
            <div class="flex-card-text">
              <h2 class="card-title">Secret-Directed Unwinding</h2>
              <h3 class="card-description"><b>Archive Of Formal Proofs (AFP 2024)</b></h3>
              <p class="card-description">
                This entry formalizes the secret-directed unwinding disproof method for relative security. The method was presented in the CSF 2024 paper "Relative Security: Formally Modeling and (Dis)Proving Resilience Against Semantic Optimization Vulnerabilities". Secret-directed unwinding can be used to prove the existence of transient execution vulnerabilities. The main characteristics of secret-directed unwinding are that (1) it is used to disprove rather than prove security and (2) it proceeds in a manner that is "directed" by given sequences of secrets. The second characteristic is shared with the unwinding method for bounded- deducibility security.
              </p>
            </div>     
            
            <a class="card-link" href="https://www.isa-afp.org/entries/Secret_Directed_Unwinding.html">
              <div class="card-highlight">
                <h3>Read more</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>
          </div>      
      </div>
      <div class="flex-card">
          <div class="flex-card-content">
            <div class="flex-card-text">
              <h2 class="card-title">More Operations on Lazy Lists</h2>
              <h3 class="card-description"><b>Archive Of Formal Proofs (AFP 2024)</b></h3>
              <p class="card-description">
                We formalize some operations and reasoning infrastructure on lazy (coinductive) lists. The operations include: building a lazy list from a function on naturals and an extended natural indicating the intended domain, take-until and drop-until (which are variations of take-while and drop-while), splitting a lazy list into a lazy list of lists with cut points being those elements that satisfy a predicate, and filtermap. The reasoning infrastructure includes: a variation of the corecursion combinator, multi-step (list-based) coinduction for lazy-list equality, and a criterion for the filtermapped equality of two lazy lists.
              </p>
            </div>     
            
            <a class="card-link" href="https://www.isa-afp.org/entries/More_LazyLists.html">
              <div class="card-highlight">
                <h3>Read more</h3>
                <img class="card-icon" src="./images/external-link.png" alt="">
              </div>
            </a>

          </div>      
      </div>
      <!--Up to this point-->
  
      <a id="button-link" href="#top">
        <div id="button">
          <p>Back to top</p>
        </div>
      </a>
          
    </main>

  </div>
  
  <!-- Footer -->
  <footer>
    <nav class="footer-style">
      <ul id="footer-menu">
        <li class="footer-link"><a class="footer-text" href="contact.html">Contact</a></li> 
      </ul>
    </nav>     
    <p class="footer-info">Copyright © * COVERT Project * All Rights Reserved</p>   
  </footer> 
</body>


</html>